//Copyright (c) 2015, David Mórász _@mcro.de
//
//Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, 
//provided that the above copyright notice and this permission notice appear in all copies.
//
//THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
//INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, 
//DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, 
//WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE 
//USE OR PERFORMANCE OF THIS SOFTWARE.
//
//Original Code : https://github.com/microdee/Emeshe-deprecated

Texture2D<float2> PrevTex: PREVIOUS;
Texture2D ColorTex: INITIAL;
#define PI 3.14159265358979

float2 ScreenSize:TARGETSIZE;

Texture2D velTex;

cbuffer controls:register(b0){
	float Amount = 0.5;
	float minvel = 0;
	float SampleFreq = 3;
	float MaxSamples = 16;
	float MinSamples = 16;
	float AltVelSampDowngrade = 3;
	float MaxBlur = .3;
	float VelMapBlur = 0.15;
	float BlurOffset = 0;
	float alphapower = 1;
	bool Aspect <bool visible=false;string uiname="Keep Aspect Ratio";> = true;
};

SamplerState s0 <bool visible=false;string uiname="Sampler";>
{
	Filter=MIN_MAG_MIP_LINEAR;
	AddressU=CLAMP;
	AddressV=CLAMP;
	MipLODBias = 0;
};

SamplerState s_vel : IMMUTABLE
{
	Filter=MIN_MAG_MIP_POINT;
	AddressU=CLAMP;
	AddressV=CLAMP;
	MipLODBias = 0;
};
float2 FillVel(float4 PosWVP:SV_POSITION,float2 uv:TEXCOORD0): SV_Target
{
    float2 colin = velTex.Sample(s_vel,uv).zw;
	float2 col = colin;
	float FillEpsilon = .1;
	
	if((colin.r<=FillEpsilon) && (colin.g<=FillEpsilon))
	{
		col = 0.5;
	}
	//if(vPos.z==0) col.rgb = 0.5;
    return col;
}
float2 pBLUR(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_Target{
	float lod=log2(max(ScreenSize.x,ScreenSize.y));
	//float4 map=tex1.SampleLevel(s0,x,0);map=max(map.x,max(map.y,map.z))*map.a;
	//lod=map.x*(VelMapBlur)*log2(max(ScreenSize.x,ScreenSize.y));
	lod=(VelMapBlur)*log2(max(ScreenSize.x,ScreenSize.y));
	float2 c=0;
	float2 off=.5/ScreenSize*pow(2,lod)*saturate(lod);
	c+=PrevTex.SampleLevel(s0,x+float2(0,0)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(1,1)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(1,-1)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(-1,-1)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(-1,1)*off,lod);
	off*=1.86;
	c+=PrevTex.SampleLevel(s0,x+float2(0,1)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(0,-1)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(-1,0)*off,lod);
	c+=PrevTex.SampleLevel(s0,x+float2(1,0)*off,lod);
	c/=9;
	return c;
}
float2 pMIPS(float4 PosWVP:SV_POSITION,float2 x:TEXCOORD0):SV_Target{
	return PrevTex.SampleLevel(s0,x,0);
}

float2 velmblur(float4 PosWVP:SV_POSITION,float2 uv:TEXCOORD0):SV_Target
{
    float2 vmap = PrevTex.Sample(s0, uv);
    float2 vel = vmap -.5;
	vel *= Amount*2;
	
	//float2 asp=lerp(1,ScreenSize.x/ScreenSize,Aspect);
	float2 asp=1;
    float2 c=0;
	int iter=saturate(length(vel.xy)*SampleFreq)*abs(MaxSamples/2-MinSamples/2)+MinSamples/2;
    for (float i=0;i<1;i+=1./iter){
        c+=PrevTex.SampleLevel(s0,((uv-.5)/asp+vel*float2(1,-1)*(i-.5-BlurOffset/2))*asp+.5,0);
    }
    c=c/iter;
    return c;
}

float4 mblur(float4 PosWVP:SV_POSITION,float2 uv:TEXCOORD0):SV_Target
{
    float2 vmap = PrevTex.Sample(s0, uv);
    float2 vel = vmap-0.5;
	vel *= Amount;
	
	//float2 asp=lerp(1,ScreenSize.x/ScreenSize,Aspect);
	float2 asp=1;
    float4 c=0;
	int iter=saturate(length(vel.xy)*SampleFreq)*abs(MaxSamples-MinSamples)+MinSamples;
    for (float i=0;i<1;i+=1./iter){
        c+=ColorTex.SampleLevel(s0,((uv-.5)/asp+vel*float2(1,-1)*(i-.5-BlurOffset/2))*asp+.5,0);
    }
    c=c/iter;
    return c;
}

technique10 MotionBlur{
	pass P0 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,FillVel()));}
	pass P1 <bool mips=true; string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pMIPS()));}
	pass P2 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pBLUR()));}
	pass P3 <string format="R16G16B16A16_Float";>
	{SetPixelShader(CompileShader(ps_5_0,mblur()));}
}
technique10 MotionBlurAltVel{
	pass P0 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,FillVel()));}
	pass P1 <bool mips=true; string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pMIPS()));}
	pass P2 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pBLUR()));}
	pass P3 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,velmblur()));}
	pass P4 <string format="R16G16B16A16_Float";>
	{SetPixelShader(CompileShader(ps_5_0,mblur()));}
}
technique10 MotionBlurAltVel2{
	pass P0 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,FillVel()));}
	pass P1 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,velmblur()));}
	pass P2 <bool mips=true; string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pMIPS()));}
	pass P3 <string format="R32G32_Float";>
	{SetPixelShader(CompileShader(ps_5_0,pBLUR()));}
	pass P4 <string format="R16G16B16A16_Float";>
	{SetPixelShader(CompileShader(ps_5_0,mblur()));}
}